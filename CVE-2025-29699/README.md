## CVE-2025-29699: Use-after-free in `_dom_node_set_text_content`

This issue affects NetSurf <= 3.11 and libdom prior to commit [6ff5b694baefbe4cebcbe42bd3cdc0657be70138](https://github.com/Fysac/libdom/commit/6ff5b694baefbe4cebcbe42bd3cdc0657be70138).

The `Node.textContent` setter is handled by libdom's `_dom_node_set_text_content` function, which removes the specified node's children and replaces them with a single text node. It calls `dom_node_remove_child` in a loop to detach each child node from the tree. After each call, it decrements the child node's reference count via `dom_node_unref`, which causes the node to be freed if the count drops to 0.

```c
dom_exception _dom_node_set_text_content(dom_node_internal *node,
		dom_string *content)
{
	dom_node_internal *n, *p, *r;
	dom_document *doc;
	dom_text *text;
	dom_exception err;

	n = node->first_child;

	while (n != NULL) {
		p = n;
		n = n->next;
		/* Add the (void *) casting to avoid gcc warning:
		 * dereferencing type-punned pointer will break 
		 * strict-aliasing rules */
		err = dom_node_remove_child(node, p, (void *) &r);
		if (err != DOM_NO_ERR)
			return err;
		/* The returned node was reffed, so unref it */
		dom_node_unref(r);
	}
    // ...
```

Reference: https://github.com/netsurf-browser/libdom/blob/2687282d56dfef19e26e9639a5c0cd81de957e22/src/core/node.c#L1486-L1507

Before and after detaching the child from the tree, `dom_node_remove_child` dispatches mutation events (such as `DOMNodeRemoved`) that hand over control to any registered JavaScript handlers.

```c
    // ...
	/* Dispatch a DOMNodeRemoval event */
	err = dom_node_dispatch_node_change_event(node->owner, old_child, node,
			DOM_MUTATION_REMOVAL, &success);
	if (err != DOM_NO_ERR)
		return err;

	/* Detach the node */
	_dom_node_detach(old_child);

	/* When a Node is removed, it should be destroy. When its refcnt is not 
	 * zero, it will be added to the document's deletion pending list. 
	 * When a Node is removed, its parent should be NULL, but its owner
	 * should remain to be the document. */
	dom_node_ref(old_child);
	dom_node_try_destroy(old_child);
	*result = old_child;

	success = true;
	err = _dom_dispatch_subtree_modified_event(node->owner, node,
			&success);
    // ...
```

Reference: https://github.com/netsurf-browser/libdom/blob/2687282d56dfef19e26e9639a5c0cd81de957e22/src/core/node.c#L987-L1006

If a registered handler sets the parent node's text content again, a nested call to `_dom_node_set_text_content` will occur, and the node's children may be freed due to the reference count decrement. When the event dispatcher of the original call chain resumes execution, it may access a freed child, resulting in a use-after-free.

Fix: libdom commit [6ff5b694baefbe4cebcbe42bd3cdc0657be70138](https://github.com/Fysac/libdom/commit/6ff5b694baefbe4cebcbe42bd3cdc0657be70138) resolved this issue by preventing modifications to the DOM from within mutation event handlers.
