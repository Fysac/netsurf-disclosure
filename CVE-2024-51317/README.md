# CVE-2024-51317

This issue affects NetSurf <= 3.11 and libdom prior to commit [7d317df204d18f161f0a8ffed958ef60eb2692fe](https://github.com/netsurf-browser/libdom/commit/7d317df204d18f161f0a8ffed958ef60eb2692fe).

`_dom_node_normalize` recurses over the descendants of the specified parent node. It combines any adjacent text nodes it encounters into a single text node, then detaches the second of the two adjacent nodes (`n`) from the tree. After detaching `n`, it decrements `n->refcnt` by calling `dom_node_unref` on it. If the reference count falls to 0, `n` is freed.

However, unreffing `n` here is incorrect, as the `refcnt` field tracks external references to the node (held by consumers of the library), not internal ones (see libdom's [reference counting documentation](https://github.com/netsurf-browser/libdom/blob/cabf9fce1e6ce4a86492a06af93a6aee8089c423/docs/RefCnt)).

As a result, the node underlying `n` may be deallocated even if external code (e.g., JavaScript) has a valid reference to it, leading to a use-after-free vulnerability.

```c
dom_exception _dom_node_normalize(dom_node_internal *node)
{
	dom_node_internal *n, *p;
	dom_exception err;

	p = node->first_child;
	if (p == NULL)
		return DOM_NO_ERR;

	n = p->next;

	while (n != NULL) {
		if (n->type == DOM_TEXT_NODE && p->type == DOM_TEXT_NODE) {
			err = _dom_merge_adjacent_text(p, n);
			if (err != DOM_NO_ERR)
				return err;

			_dom_node_detach(n);
			dom_node_unref(n);
			n = p->next;
			continue;
		}
		if (n->type != DOM_TEXT_NODE) {
			err = dom_node_normalize(n);
			if (err != DOM_NO_ERR)
				return err;
		}
		p = n;
		n = n->next;
	}

	return DOM_NO_ERR;
}
```

Reference: https://github.com/netsurf-browser/libdom/blob/2687282d56dfef19e26e9639a5c0cd81de957e22/src/core/node.c#L1165-L1197

Fix: libdom commit [7d317df204d18f161f0a8ffed958ef60eb2692fe](https://github.com/netsurf-browser/libdom/commit/7d317df204d18f161f0a8ffed958ef60eb2692fe) addressed this issue by replacing the call to `dom_node_unref` with a call to `dom_node_try_destroy`, which frees the node only if its reference count is already 0; otherwise, it adds the node to a pending list for future destruction.